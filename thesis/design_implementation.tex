\chapter{Design and Implementation}
\label{chapter:design}

Based on the requirements identified in the previous chapter, we're in this chapter introducing the design and implementation details of the of our proposed proxy solution. We get started by discussing the overall design, before we dive into the implementations details.



\section{Design of Solution}

In previous chapters we have argued that all optimization techniques should be
placed in proxies in order to retains interoperability for COTS applications, as
well as to break their end-to-end dependency. Our design therefore deploying a
proxy pair to facilitate Web communication. The idea is to deploy the proxy pair
in two different locations separated by a DIL network. Through the locally
deployed proxy can then Web applications proxy all their communication. The
proxy will then apply different optimization techniques, and over over a DIL
network forward the request to the other proxy, and finally return a response.
Ideally should a proxy be deployed as close to its intended user applications as
possible, preferable at the same machine.


It is worth noting that since the proxies is designed to accept \textit{all} HTTP
requests, they can support any applications that utilize HTTP, including request-
response and publish-subscribe applications.


\subsection{Design of HTTP proxy}

A deployed proxy is designed to accept arbitrary HTTP requests, possible from
multiple clients, and forward them to the other proxy as seen in
\cref{figure:proxy_design}. Ideally the proxy should be deployed as close to its
intended users as possible, as the communication between an application and its
proxy is not subject to any optimization for DIL environments.

\begin{figure}[h]
\includegraphics[scale=0.55]{images/proxy_design.pdf}
\caption{Design of Solution}
\label{figure:proxy_design}
\end{figure}

It is the communication between a proxy pair that is subject to optimizations.
The proxies are therefore designed to support the optimization techniques we
have identified. Those are primarily concerned about using different transport
protocols as the inter-proxy communication, as illustrated in
\cref{figure:proxy-communication}. The purpose of this is to evaluate the
performance of the transport protocols in DIL networks. Which protocol to use as
the means of inter-proxy communication is therefore designed to be easily
configured by the user of the proxy.

\begin{figure}[h]
\includegraphics[scale=0.5]{images/proxy_communcation.pdf}
\caption{The proxies were designed to support multiple protocols for inter-proxy communication}
\label{figure:proxy-communication}
\end{figure}

\section{Choosing a Framework}

Requirement one implies creating a HTTP proxy which accepts HTTP requests,
forward them, and finally return a HTTP response. We identified some approaches:

\begin{enumerate}
    \item Build a HTTP proxy from scratch ourself.
    \item Use an existing HTTP proxy.
\end{enumerate}

Building a HTTP proxy ourself would allow us to customize our solutions as we
wanted, but would require a lot of implementation. We therefore concluded that
best use of our resources was to use an existing configurable proxy. Building on
state-of-art existing solutions allowing us to focus on the optimization
techniques, rather than on the specific low-level details of HTTP. There are
numerous HTTP proxies available for use, for an example Nginx and Squid.

Another one is Apache Camel, which is an open source Java framework developed by
the Apache Software Foundation for rule-based routing and
mediation\cite{camel-homepage}. It has a wide range of use-cases and focuses on
making integration between different enterprise communication system easier. It
support a large set of different communication transports (transport protocols).
We chose to use Apache Camel as our HTTP proxy due to its simplicity and support
for different transport protocols.

\subsection{Apache Camel}

Routing is a central concept in Apache Camel and consist of defining a
\textit{from route}. This is an endpoint from which Camel consumes messages. It
can then invoke a series of \textit{processors}, which can modify the headers,
payload etc. of the message. Then, Camel forwards the message to a \textit{to
route}, which can be an application running somewhere else. When a response is
received, Camel can invoke a new set of processors on the message, before it is
finally returned to the origin. An overview of this can be seen in
\cref{figure:camel-route}.

Describe Camel Components.

\begin{figure}[h]
\centering
\includegraphics[scale=0.7]{images/camel_routes.pdf}
\caption{Example of a Camel route}
\label{figure:camel-route}
\end{figure}

\section{Implementation}

The proxy was implemented as a Java 1.8 application using the Apache Camel
framework. A large part of the implementation is concerned about reading user
configuration and setting up \textit{routing rules} for Apache camel. The stages
of the program are as follows:

\begin{enumerate}
    \item Reading and parsing user configuration.
    \item Initializing Camel components.
    \item Setting up routes.
    \item Running.
\end{enumerate}

\subsection{Parsing Configuration}

The first stage involves reading a user provided configuration file. Details about the configuration is explained in section X.

\subsection{Initializing Components}

Depending on which protocol the user has selected for usage as inter-proxy
communication, at startup the respective Camel component is initiated  and added
to the Camel context.

Due to the time available, we did not implement support for all of the
recommendation protocols from the last chapter. The currently supported protocols
are HTTP, AMQP and CoAP. However, the proxy is designed to by easily extended to
include additional protocols.

\subsubsection{HTTP Component}

We made use of the Camel component Jetty in order to consume and produce HTTP
requests. The component is based on the Jetty Web server\cite{jetty-homepage}.
It was used for two purposes: to consume \gls{http} requests from applications
and if HTTP was configured,as the selected protocol, to consume/produce HTTP
messages as part of the inter-proxy communication.

\subsubsection{AMQP Component}

Describe AMQP component.

\subsubsection{CoAP Component}

Describe CoAP component

\subsection{Routes}

A running proxy listens on two \textit{routes}. It can either receive messages
from an application, or it can receive a message from the other proxy. This
setup can be seen in \cref{figure:dil-routes}. The routing logic is different
for these two cases. We define a request origination from an outside application
as the \textit{application route}, and a request origination from another proxy
as a \textit{proxy route}. We discuss these routes, but first we need to
introduce what we have chose to call the \textit{proxy message format}.
Requirement 2 says that we need to retain all the original HTTP headers from the
original request. Consider if the proxy receives a HTTP request and forwards it
to the other protocol using AMQP. The message itself will arrive correctly, but
the original HTTP headers and method would be lost. Our approach to this was to
introduce a custom \textit{proxy message format}, which is discussed in the next
section.

\begin{figure}[h]
\centering
\includegraphics[scale=0.7]{images/dil_routes.pdf}
\caption{Proxy routes}
\label{figure:dil-routes}
\end{figure}

\subsection{Proxy Message Format}

The proxy message format was developed to retain HTTP headers and other
necessary information about the request. Our solution was to wrap all messages
in a \gls{json} document and include necessary information as properties in the
JSON document. JSON is a lightweight, text-based data format\cite{rfc-json}. We
chose this data format due to its compactness, simplicity and the wide support
for libraries for generating and parsing JSON. Due to a HTTP request and
response having slightly different semantics, we used the same format, but
with different properties for a request and response. The request format is
defined in \cref{table-proxy-request}, and the response format in
\cref{table-proxy-response}.

\begin{table}[h]
\begin{tabularx}{\textwidth}{|l|X|l|}
\hline
\textbf{Field} & \textbf{Purpose}                                                                                                      & \textbf{Required} \\ \hline
path           & The original request URL from the application. Specifies the intended final destination of the original HTTP request. & Yes               \\ \hline
method         & HTTP method of the request.                                                                                           & Yes               \\ \hline
query          & Query string associated with the original HTTP request.                                                               & No                \\ \hline
headers        & JSON object containing all the original HTTP headers of the request                                                   & Yes               \\ \hline
body           & The original payload of the message                                                                                   & No                \\ \hline
\end{tabularx}
\caption{Proxy message request fields}
\label{table-proxy-request}
\end{table}

\begin{table}[h]
\begin{tabularx}{\textwidth}{|l|X|l|}
\hline
\textbf{Field} & \textbf{Purpose}   & \textbf{Required} \\ \hline
headers        & JSON object containing the HTTP response headers. & Yes  \\ \hline
responsecode   & The HTTP response code. & Yes \\ \hline
body           & Response body of the HTTP request. & No            \\ \hline
\end{tabularx}
\caption{Proxy message response fields}
\label{table-proxy-response}

\end{table}

An example proxy request message is included in \cref{listing:proxy-request}.
The listing illustrates a HTTP request originating from an outside application.
It was a POST to the intended destination http://myservice.com, with a XML
message as payload.

\lstinputlisting[frame=single, language=json, firstnumber=1, caption="Example proxy request", label=listing:proxy-request]{listings/proxy_message.json}

\paragraph{}

\subsection{Application Route}

The purpose of the application route is to consume HTTP requests from an
outside HTTP request, transform it to a proxy request message and deliver it
to the other proxy. When a response is received, return it to the application.
The route consist of the following steps:

\begin{enumerate}
	\item Defining a HTTP endpoint to consume HTTP requests from. This is read from the configuration which specifies which hostname and port to listen on.
	\item Consume HTTP request from an outside application
	\item Apply the \textit{ProxyRequestPreProcessor}. This processor converts the message into a Proxy Request Message.
	\item If compression is enabled, compress the entire message.
	\item Forward the request to the other proxy using the configured transport protocol.
	\item Receive an response from the other proxy.
	\item If compression is enabled, de-compress the message.
	\item Restore the HTTP response from Proxy Response Message.
	\item Return the response to the application.
\end{enumerate}

\subsection{Proxy Route}

The purpose of the proxy route is to listen for messages from the other proxy,
de-serialize it, and deliver it to its intended receiver. When a response is
received, transform it into a Proxy Response Message and return it to the other
proxy. The route consist of the following steps:

\begin{enumerate}
	\item Defining a endpoint depending on which the configured protocol.
	\item Consume requests from the other proxy.
	\item If compression is enabled, de-compress the message.
	\item Transform the message into the original HTTP request.
	\item Forward the HTTP request to its intended destination.
	\item Receive a HTTP response from the intended destination.
	\item Transform it into a Proxy Response Message.
	\item If compression is enabled, compress the message.
	\item Return the response to the other application.
\end{enumerate}

\subsection{Dealing with Errors}

Discuss retransmission mechanisms

\subsection{Runtime}

In the running stage, the proxy listens on the defined routes and forward them
according to the previously configured routes. All requests are logged.


\section{Functionality}

The prototype is packaged as an JAR an can be started from the command line. A
path to a valid configuration file must be passed as a command line argument.


\subsection{Configuration}

\lstinputlisting[frame=single, language=json, firstnumber=1, caption="Example proxy configuration file", label=listing:proxy-config]{listings/amqp.conf}


\subsection{Proxy Setup}

In order to enable the applications to tunnel all their HTTP traffic through our
proxy, we needed a way to setup a proxy without altering the applications
themselves. Fortunately, Java provide mechanisms to deal with
proxies\cite{oracle-proxy}. We configured the \gls{jvm} to get the applications
to tunnel all HTTP traffic through our proxy. This is done by setting properties
to the \gls{jvm}:


\begin{lstlisting}[frame=single, caption="Setting a proxy on the \gls{jvm}", label=test]
java -Dhttp.proxyHost=localhost \
-Dhttp.proxyPort=3001 \
-Dhttp.nonProxyHosts= \
-jar target/client.jar
\end{lstlisting}

In \cref{test} the application \textbf{client.jar} is started and all HTTP
traffic will go through the proxy server at localhost on port 3001.



\section{Summary}

In this chapter we presented the design and implementation details of the proxy.
